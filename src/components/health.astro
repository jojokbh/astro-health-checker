---

interface Endpoint {
  name: string;
  url: string;
}

interface EndpointStatus extends Endpoint {
  status: string;
  statusCode?: number;
}

const endpoints: Endpoint[] = [
  { name: "Google", url: "https://www.google.com" },
  { name: "Cloudflare", url: "https://www.cloudflare.com" },
  { name: "Example API (Healthy)", url: "https://jsonplaceholder.typicode.com/todos/1" },
  { name: "Example API (Not Found)", url: "https://jsonplaceholder.typicode.com/nonexistent" },
  { name: "Invalid URL", url: "invalid-url-should-fail" },
];

// Simple in-memory cache
interface CacheData {
  statuses: EndpointStatus[];
  lastChecked: number; // Timestamp
}

// Use a symbol for a unique global key to avoid collisions
const HEALTH_CHECK_CACHE_KEY = Symbol.for('astroHealthCheckerCache');

// Helper to get/set the cache from globalThis
function getGlobalCache(): CacheData | null {
  if (typeof globalThis !== 'undefined' && (globalThis as any)[HEALTH_CHECK_CACHE_KEY]) {
    return (globalThis as any)[HEALTH_CHECK_CACHE_KEY];
  }
  return null;
}

function setGlobalCache(data: CacheData): void {
  if (typeof globalThis !== 'undefined') {
    (globalThis as any)[HEALTH_CHECK_CACHE_KEY] = data;
  }
}

const CACHE_DURATION_MS = 60 * 1000; // 1 minute

Astro.response.headers.set('Cache-Control', 'public, s-maxage=60, stale-while-revalidate=30'); // Corrected Cache-Control


async function getEndpointStatuses(): Promise<CacheData> {
  let currentCache = getGlobalCache();
  console.log("last fetched ", currentCache?.lastChecked);
  const now = Date.now();

  if (currentCache && (now - currentCache.lastChecked < CACHE_DURATION_MS)) {
    // console.log("Returning cached data");
    return currentCache;
  }

  // console.log("Fetching new data");
  const statuses: EndpointStatus[] = await Promise.all(
    endpoints.map(async (endpoint) => {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 seconds timeout

      try {
        const response = await fetch(endpoint.url, { 
          method: 'HEAD', 
          signal: controller.signal 
        });
        console.log("fetching ", endpoint.url);
        clearTimeout(timeoutId); // Clear timeout if fetch completes
        return {
          ...endpoint,
          status: response.ok ? 'Healthy' : 'Unhealthy',
          statusCode: response.status,
        };
      } catch (error: any) {
        return {
          ...endpoint,
          status: 'Error',
          statusCode: undefined,
        };
      }
    })
  );

  const newCacheData = { statuses, lastChecked: now };
  setGlobalCache(newCacheData);
  return newCacheData;
}

const { statuses: endpointStatuses, lastChecked } = await getEndpointStatuses();
const lastCheckedDate = new Date(lastChecked);

const getStatusClasses = (status: string) => {
  switch (status) {
    case 'Healthy':
      return {
        bg: 'bg-green-700/20',
        border: 'border-green-500',
        text: 'text-green-400',
        pillBg: 'bg-green-500/80',
        pillText: 'text-green-50',
      };
    case 'Unhealthy':
      return {
        bg: 'bg-yellow-700/20',
        border: 'border-yellow-500',
        text: 'text-yellow-400',
        pillBg: 'bg-yellow-500/80',
        pillText: 'text-yellow-50',
      };
    default: // Error
      return {
        bg: 'bg-red-700/20',
        border: 'border-red-500',
        text: 'text-red-400',
        pillBg: 'bg-red-500/80',
        pillText: 'text-red-50',
      };
  }
};
---

<main class="container mx-auto p-6 md:p-8">
  <header class="mb-10 text-center">
    <h1 class="text-4xl md:text-5xl font-bold tracking-tight text-slate-50 mb-3">
      Endpoint Health Status
    </h1>
    <p class="text-slate-400 text-lg">
      Live status of our critical services.
    </p>
  </header>

  <div class="mb-8 text-center">
    <p class="text-sm text-slate-500">
      Last checked: <span id="lastCheckedTime" class="font-medium text-slate-400">{lastCheckedDate.toLocaleString()}</span>
    </p>
  </div>

  <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
    {endpointStatuses.map((endpoint) => {
      const statusClasses = getStatusClasses(endpoint.status);
      return (
        <div class={`
          ${statusClasses.bg} 
          border-l-4 ${statusClasses.border}
          rounded-lg shadow-xl 
          p-6 
          transition-all duration-300 ease-in-out
          hover:shadow-2xl hover:scale-[1.02]
        `}>
          <div class="flex justify-between items-start mb-3">
            <h2 class="text-2xl font-semibold text-slate-100">{endpoint.name}</h2>
            <span class={`
              px-3 py-1 text-xs font-semibold rounded-full
              ${statusClasses.pillBg} ${statusClasses.pillText}
            `}>
              {endpoint.status}
              {endpoint.statusCode && ` (${endpoint.statusCode})`}
            </span>
          </div>
          <p class="text-sm text-slate-400 break-all mb-4">
            URL: <a href={endpoint.url} target="_blank" rel="noopener noreferrer" class="text-sky-400 hover:text-sky-300 hover:underline transition-colors">
              {endpoint.url}
            </a>
          </p>
          {/* Additional details can be added here if needed */}
        </div>
      );
    })}
  </div>

  <footer class="mt-12 pt-8 border-t border-slate-700 text-center">
    <p class="text-sm text-slate-500">
      Health checks are performed server-side and cached for 1 minute.
      Powered by <a href="https://astro.build" target="_blank" rel="noopener noreferrer" class="text-sky-400 hover:text-sky-300">Astro</a>
      & <a href="https://tailwindcss.com" target="_blank" rel="noopener noreferrer" class="text-sky-400 hover:text-sky-300">Tailwind CSS</a>.
    </p>
  </footer>
</main>
